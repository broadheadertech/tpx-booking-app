<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>TPX — Multi-Branch Schema (Modern ERD)</title>
<style>
  :root{
    --bg: #f6f8fb;
    --card-bg: #ffffff;
    --muted: #6b7280;
    --blue: #2563eb;
    --green: #059669;
    --orange: #d97706;
    --edge-gap: 12;
    font-family: Inter, "Segoe UI", Roboto, system-ui, -apple-system, "Helvetica Neue", Arial;
  }
  html,body{height:100%; margin:0; background:var(--bg); color:#0f172a;}
  .container{max-width:1280px; margin:28px auto; padding:20px;}
  header{display:flex; align-items:center; justify-content:space-between; gap:16px; margin-bottom:18px}
  header h1{margin:0; font-size:20px; letter-spacing:-0.2px}
  header p{margin:0; color:var(--muted); font-size:13px}

  .canvas {
    position:relative;
    width:100%;
    height:820px;
    background:linear-gradient(180deg, rgba(255,255,255,0.8), rgba(255,255,255,0.8));
    border-radius:12px;
    border:1px solid #e8eef6;
    box-shadow:0 10px 30px rgba(11,15,30,0.06);
    overflow:visible;
  }

  /* Entity card */
  .entity {
    position:absolute;
    width:260px;
    border-radius:10px;
    background:var(--card-bg);
    padding:12px;
    box-shadow: 0 10px 22px rgba(17,24,39,0.05);
    border:1px solid #e6ecf6;
    box-sizing:border-box;
    z-index:2;
  }
  .entity h3 {
    margin:0 0 8px 0;
    padding:8px 10px;
    border-radius:8px;
    font-size:14px;
    color:#fff;
    display:inline-block;
    font-weight:700;
  }
  .entity .list{margin:0; padding-left:18px; color:var(--muted); font-size:13px; line-height:1.6}

  /* color styles */
  .core h3{ background: linear-gradient(90deg,#2563eb,#1e40af); }
  .user h3{ background: linear-gradient(90deg,#059669,#047857); }
  .trans h3{ background: linear-gradient(90deg,#d97706,#92400e); }

  /* svg lines behind the cards */
  svg#links { position:absolute; left:0; top:0; width:100%; height:100%; z-index:1; pointer-events:none; overflow:visible; }
  .link { stroke:#2b3440; stroke-width:1.4; fill:none; stroke-linecap:round; stroke-linejoin:round; opacity:0.9 }
  .joint { fill:#fff; stroke:#cbd5e1; stroke-width:1; }
  .crow { stroke:#2b3440; stroke-width:1.6; stroke-linecap:round; }

  /* small legend bottom */
  .legend { margin-top:10px; color:var(--muted); font-size:13px; text-align:center }
  @media (max-width:1100px){
    .canvas { height:1000px }
  }
  @media (max-width:720px){
    .canvas { height:1400px }
    .entity{ width:86%; left:7%; transform:none !important }
  }
</style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>TPX — Multi-Branch Booking Schema (modern ERD)</h1>
        <p>Automatic orthogonal routing, clear anchors, and crow's-foot notation.</p>
      </div>
      <div style="text-align:right">
        <small style="color:var(--muted)">Tip: Resize the window — connectors redraw automatically.</small>
      </div>
    </header>

    <div class="canvas" id="canvas">
      <!-- SVG layer for connectors -->
      <svg id="links" viewBox="0 0 1280 820" preserveAspectRatio="xMinYMin meet"></svg>

      <!-- Entities (absolute positioning) -->
      <div class="entity core" id="branches" style="left: 510px; top: 28px;">
        <h3>Branches</h3>
        <ul class="list">
          <li>branch_code (unique)</li>
          <li>name, address</li>
          <li>phone, email, is_active</li>
        </ul>
      </div>

      <div class="entity user" id="users" style="left: 70px; top: 180px;">
        <h3>Users</h3>
        <ul class="list">
          <li>user_id</li>
          <li>username, email</li>
          <li>role (super_admin / branch_admin / staff / barber / customer)</li>
          <li>branch_id (nullable for super_admin)</li>
        </ul>
      </div>

      <div class="entity core" id="services" style="left: 940px; top: 180px;">
        <h3>Services</h3>
        <ul class="list">
          <li>service_id</li>
          <li>name, price</li>
          <li>duration_minutes</li>
          <li>branch_id</li>
        </ul>
      </div>

      <div class="entity core" id="bookings" style="left: 510px; top: 320px;">
        <h3>Bookings</h3>
        <ul class="list">
          <li>booking_id, booking_code</li>
          <li>customer_id (user)</li>
          <li>barber_id</li>
          <li>service_id, branch_id</li>
        </ul>
      </div>

      <div class="entity trans" id="transactions" style="left: 120px; top: 520px;">
        <h3>Transactions</h3>
        <ul class="list">
          <li>transaction_id</li>
          <li>services[], products[]</li>
          <li>processed_by (user)</li>
          <li>branch_id</li>
        </ul>
      </div>

      <div class="entity trans" id="payments" style="left: 900px; top: 520px;">
        <h3>Payments</h3>
        <ul class="list">
          <li>payment_id</li>
          <li>booking_id</li>
          <li>amount, payment_method</li>
          <li>status</li>
        </ul>
      </div>
    </div>

    <div class="legend">
      Branch -> (1 → *) Users / Services / Bookings / Transactions. Bookings connect to Transactions & Payments.
    </div>
  </div>

<script>
/* Automatic orthogonal routing between elements.
   - Connections list below
   - The script computes sensible anchor sides and draws L-shaped paths through a midpoint.
   - Crow's foot markers drawn at the child end.
*/
(function(){
  const svg = document.getElementById('links');
  const canvas = document.getElementById('canvas');
  const GAP = 12;

  const connections = [
    {from: 'branches', to: 'users'},
    {from: 'branches', to: 'services'},
    {from: 'branches', to: 'bookings'},
    {from: 'users', to: 'bookings'},
    {from: 'services', to: 'bookings'},
    {from: 'bookings', to: 'transactions'},
    {from: 'bookings', to: 'payments'}
  ];

  function clearSvg(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }

  function createDefs(){
    const ns = svg.namespaceURI;
    let defs = document.createElementNS(ns,'defs');
    // arrow marker
    let m = document.createElementNS(ns,'marker');
    m.setAttribute('id','arrow'); m.setAttribute('markerWidth','10'); m.setAttribute('markerHeight','10');
    m.setAttribute('refX','10'); m.setAttribute('refY','5'); m.setAttribute('orient','auto'); m.setAttribute('markerUnits','strokeWidth');
    let p = document.createElementNS(ns,'path');
    p.setAttribute('d','M0,0 L10,5 L0,10 Z'); p.setAttribute('fill','#2b3440');
    m.appendChild(p);
    defs.appendChild(m);
    svg.appendChild(defs);
  }

  function getBox(el){
    const r = el.getBoundingClientRect();
    const wrap = canvas.getBoundingClientRect();
    return {
      left: r.left - wrap.left,
      top: r.top - wrap.top,
      right: r.right - wrap.left,
      bottom: r.bottom - wrap.top,
      width: r.width,
      height: r.height,
      cx: (r.left - wrap.left) + r.width/2,
      cy: (r.top - wrap.top) + r.height/2
    };
  }

  function chooseAnchors(aBox, bBox){
    const dx = bBox.cx - aBox.cx;
    const dy = bBox.cy - aBox.cy;
    if (Math.abs(dx) > Math.abs(dy)){
      // horizontal separation
      return dx > 0 ? ['right','left'] : ['left','right'];
    } else {
      // vertical separation
      return dy > 0 ? ['bottom','top'] : ['top','bottom'];
    }
  }

  function anchorPoint(box, side, offset=GAP){
    switch(side){
      case 'top': return {x: box.cx, y: box.top - offset};
      case 'bottom': return {x: box.cx, y: box.bottom + offset};
      case 'left': return {x: box.left - offset, y: box.cy};
      case 'right': return {x: box.right + offset, y: box.cy};
      default: return {x: box.cx, y: box.cy};
    }
  }

  function drawPath(points){
    const ns = svg.namespaceURI;
    const path = document.createElementNS(ns,'path');
    const d = points.map((p,i)=> (i===0?`M ${p.x} ${p.y}`:`L ${p.x} ${p.y}`)).join(' ');
    path.setAttribute('d', d);
    path.setAttribute('class','link');
    path.setAttribute('marker-end','url(#arrow)');
    svg.appendChild(path);
    return path;
  }

  function drawCrowFoot(pt, side){
    const ns = svg.namespaceURI;
    const group = document.createElementNS(ns,'g');
    group.setAttribute('class','crowfoot');
    // size and orientation
    const s = 10;
    // draw three small prongs
    if (side === 'left'){
      const p1 = document.createElementNS(ns,'path');
      p1.setAttribute('d', `M ${pt.x+6} ${pt.y-8} L ${pt.x-2} ${pt.y} L ${pt.x+6} ${pt.y+8}`);
      p1.setAttribute('class','crow');
      svg.appendChild(p1);
    } else if (side === 'right'){
      const p1 = document.createElementNS(ns,'path');
      p1.setAttribute('d', `M ${pt.x-6} ${pt.y-8} L ${pt.x+2} ${pt.y} L ${pt.x-6} ${pt.y+8}`);
      p1.setAttribute('class','crow');
      svg.appendChild(p1);
    } else if (side === 'top'){
      const p1 = document.createElementNS(ns,'path');
      p1.setAttribute('d', `M ${pt.x-8} ${pt.y+6} L ${pt.x} ${pt.y-2} L ${pt.x+8} ${pt.y+6}`);
      p1.setAttribute('class','crow');
      svg.appendChild(p1);
    } else { // bottom
      const p1 = document.createElementNS(ns,'path');
      p1.setAttribute('d', `M ${pt.x-8} ${pt.y-6} L ${pt.x} ${pt.y+2} L ${pt.x+8} ${pt.y-6}`);
      p1.setAttribute('class','crow');
      svg.appendChild(p1);
    }
  }

  function drawConnections(){
    clearSvg();
    createDefs();

    connections.forEach(c => {
      const fromEl = document.getElementById(c.from);
      const toEl = document.getElementById(c.to);
      if (!fromEl || !toEl) return;
      const A = getBox(fromEl);
      const B = getBox(toEl);
      const [sideFrom, sideTo] = chooseAnchors(A,B);
      const pStart = anchorPoint(A, sideFrom);
      const pEnd = anchorPoint(B, sideTo);

      // choose mid x (or mid y if vertical case)
      let midX = (pStart.x + pEnd.x) / 2;
      let midY = (pStart.y + pEnd.y) / 2;

      // Build orthogonal route with three segments: start -> (midX,start.y) -> (midX,end.y) -> end
      // But if near vertical, do vertical-first
      let points;
      if (Math.abs(pStart.x - pEnd.x) < 40){ // mostly vertical
        points = [pStart, {x: pStart.x, y: pEnd.y}, pEnd];
      } else if (Math.abs(pStart.y - pEnd.y) < 40){ // mostly horizontal
        points = [pStart, {x: pEnd.x, y: pStart.y}, pEnd];
      } else {
        points = [pStart, {x: midX, y: pStart.y}, {x: midX, y: pEnd.y}, pEnd];
      }

      // Slightly inset final point so arrow end doesn't touch the crow's foot area
      const insetAmount = 8;
      // draw main path
      const path = drawPath(points);

      // draw small joint circles on intermediate corners for style
      const ns = svg.namespaceURI;
      points.slice(1, -1).forEach(pt=>{
        const circle = document.createElementNS(ns,'circle');
        circle.setAttribute('cx', pt.x);
        circle.setAttribute('cy', pt.y);
        circle.setAttribute('r', 3);
        circle.setAttribute('class', 'joint');
        svg.appendChild(circle);
      });

      // draw crow's foot near the target (child) side
      // position slightly before pEnd so it sits just outside the child box
      drawCrowFoot(pEnd, sideTo);
    });
  }

  // redraw when page resizes / fonts load
  let frame = null;
  function schedule(){
    if (frame) cancelAnimationFrame(frame);
    frame = requestAnimationFrame(()=>{ drawConnections(); frame=null; });
  }
  window.addEventListener('resize', schedule);
  document.addEventListener('DOMContentLoaded', schedule);
  // init
  schedule();
})();
</script>
</body>
</html>
